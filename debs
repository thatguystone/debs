#!/usr/bin/env python

import argparse
import glob
import os.path
import platform
import re
import subprocess
import sys

DEFAULT_REMOTE = 'default'
CURRENT_STABLE = 'wheezy'
PYARCH_TO_DEBARCH = {
	'i386': 'i386',
	'x86_64': 'amd64'
}
GEN_GLOBS = [
	'../*_*.build',
	'../*_*.changes',
	'../*_*.deb',
	'../*_*.dsc',
	'../*_*.tar.gz',
	'../*_*.tar.xz',
	'../*_*.build',
	'../*_*.upload',
]

def run(cmd):
	p = subprocess.Popen(cmd,
		stdout=subprocess.PIPE,
		stderr=subprocess.PIPE)
	p.wait()

	if p.returncode != 0:
		raise Exception('`%s` exited with %d' % (' '.join(cmd), p.returncode))

	return p.communicate()[0]

def check_run(args):
	print 'I: running `%s`' % ' '.join(args)

	try:
		p = subprocess.Popen(args)
		p.wait()
		if p.returncode != 0:
			raise RunException(p.returncode)
	finally:
		p.wait()

def run_sbuild(arch, dist, pkg, pkg_name):
	while True:
		try:
			check_run(['sbuild', '--source', '--arch', arch, '--dist', dist, pkg])
			return
		except RunException as e:
			res = raw_input(
				'E: `%s` on %s-%s failed with exit code %d. '
				'Try again? [y/N] '
					% (pkg_name, dist, arch, e.code))
			if res != 'y':
				raise

class RunException(Exception):
	def __init__(self, code):
		self.code = code

	def __str__(self):
		return 'Command exited with status: %d' % self.code

class Dists(object):
	default = '%s-%s' % (CURRENT_STABLE, PYARCH_TO_DEBARCH[platform.machine()])
	dists = set()

	def __init__(self):
		envs = run(['schroot', '-l', '--all'])
		envs = [e.replace('source:', '').replace('-sbuild', '').replace('chroot:', '')
			for e in envs.split('\n')
			if e.endswith('sbuild')]

		for e in envs:
			self.dists.add(e)

		if not self.dists:
			raise Exception('no sbuild environments found')

		if self.default not in self.dists:
			self.default = self.dists[0]

	def dump(self):
		print 'Available dists (*default):'
		for d in self.get_all():
			star = '*' if d == self.default else ' '
			print '   %s%s' % (star, d)
		sys.exit(0)

	def get_all(self):
		return self.dists

	def get(self, dists):
		ds = set()

		if not dists:
			ds.add(self.default)
		elif 'all' in dists:
			ds = self.get_all()
		else:
			for dist in dists:
				for d in self.dists:
					if d.startswith(dist) or d.endswith(dist):
						ds.add(d)

		return ds

class Remotes(object):
	hosts = []
	default = None

	def __init__(self):
		hosts = run(['dput', '--host-list'])
		for h in hosts.split('\n'):
			if len(h.strip()) == 0 or 'Default Method' in h:
				continue
			hh = h.split('  ')[0].split(' => ')
			if hh[0] == DEFAULT_REMOTE:
				self.default = hh[0]
			self.hosts.append(hh)

		if not self.default:
			raise Exception('Default remote %s not found' % DEFAULT_REMOTE)

	def dump(self):
		print 'Available remotes (*default):'
		for h in self.hosts:
			star = '*' if h[0] == self.default else ' '
			print '   %s%s (%s)' % (star, h[0], h[1])
		sys.exit(0)

	def get(self, rs):
		hosts = []

		if not rs:
			hosts.append(self.default)
		else:
			for h in self.hosts:
				if h[0] in rs:
					hosts.append(h[0])

		return hosts

def update(dists):
	for d in dists:
		parts = d.split('-')
		check_run(['sudo', 'sbuild-update', '-udcar', '--arch', parts[1], parts[0]])
	sys.exit(0)

def find_changes_file(outdir, pkg):
	files = glob.glob('%s/%s*.changes' % (outdir, pkg))
	if not files:
		raise Exception('Changes file for %s not found' % pkg)
	return files[0]

def clean():
	for g in GEN_GLOBS:
		for f in glob.glob(g):
			os.unlink(f)
	sys.exit(0)

def rm_gen_files(outdir, pkg, changes):
	with open(changes) as f:
		ch = f.read()

	fs = list([changes] +
		['%s/%s' % (outdir, f) for f in re.findall(r'\w{32} \d* \w* \w* (.*)', ch)] +
		glob.glob('%s/%s*.build' % (outdir, pkg)) +
		glob.glob('%s/%s*.upload' % (outdir, pkg)))
	for f in fs:
		os.unlink(f)

dists = Dists()
remotes = Remotes()

parser = argparse.ArgumentParser(description='Build a Debian package and dput it')
parser.add_argument(
	'packages', metavar='PACKAGE[.dsc]', type=str, nargs='*',
	help='which package(s) to build')
parser.add_argument(
	'-c', '--clean',
	action='store_true',
	help='clean up all debian-generated files in this directory')
parser.add_argument(
	'-d', '--dist',
	type=str,
	action='append',
	help='which distro to use (may be given multiple times). '+
		'use "all" to build in all. '+
		'otherwise, does prefix/suffix matching on the given values')
parser.add_argument(
	'--list-dists',
	action='store_true',
	help='list all dists known to sbuild')
parser.add_argument(
	'-r', '--remote',
	type=str,
	action='append',
	help='which remote to use (may be given multiple times)')
parser.add_argument(
	'--list-remotes',
	action='store_true',
	help='list all remotes known to dput')
parser.add_argument(
	'-u', '--update',
	action='store_true',
	help='perform apt-get upgrades in the matched dists')

args = parser.parse_args()

if args.clean:
	clean()

if os.path.exists('.debs'):
	with open('.debs') as f:
		parser.parse_args(f.read().split(), namespace=args)

if args.list_dists:
	dists.dump()
if args.list_remotes:
	remotes.dump()

ds = dists.get(args.dist)
rs = remotes.get(args.remote)

if not ds:
	raise Exception('No dists matched')
if not rs:
	raise Exception('No remotes matched')

if args.update:
	update(ds)

pkgs = []

if not args.packages:
	args.packages = ['.']

for pkg in args.packages:
	if not os.path.exists(pkg):
		raise Exception('Package %s not found' % pkg)

	if pkg.endswith('.dsc'):
		pkgs.append((pkg, pkg.split('_')[0]))
	else:
		ctrl = '%s/debian/control' % pkg
		if not os.path.isfile(ctrl):
			raise Exception('%s not found' % ctrl)
		with open(ctrl) as f:
			head = f.readline().strip()
		name = head.split(':')[1].strip()
		pkgs.append((pkg, name))

print 'Going to build:'
for pkg in pkgs:
	print '    `%s` for' % pkg[1]
	for d in ds:
		print '        %s' % d

print
res = raw_input('Confirm? [y/N] ')
if res != 'y':
	print 'Aborting...'
	sys.exit(1)

for pkg in pkgs:
	outdir = os.path.abspath('%s/..' % pkg[0])
	for d in ds:
		parts = d.split('-')
		run_sbuild(parts[1], parts[0], pkg[0], pkg[1])
		changes = find_changes_file(outdir, pkg[1])
		for r in rs:
			check_run(['dput', r, changes])
		rm_gen_files(outdir, pkg[1], changes)
