#!/usr/bin/env python

from __future__ import print_function

import argparse
import copy
import getpass
import glob
import json
import multiprocessing
import os
import os.path
import platform
import re
import shutil
import subprocess
import sys
import tempfile

CFG_FILE = '.debs'
VERSIONS_FILE = CFG_FILE + '-versions'

DEFAULT_REMOTE = 'default'
CURRENT_STABLE = 'jessie'
PYARCH_TO_DEBARCH = {
	'i386': 'i386',
	'x86_64': 'amd64'
}

SBUILD_ARCHS = set(PYARCH_TO_DEBARCH.values())
SBUILD_REPO_URLS = {
	'debian': 'http://httpredir.debian.org/debian',
	'ubuntu': 'http://us.archive.ubuntu.com/ubuntu/',
}
SBUILD_COMPONENTS = {
	'debian': 'main,contrib,non-free',
	'ubuntu': 'main,restricted,universe,multiverse',
}

CHANGELOG_VERSION = re.compile(r'.* \((.*)\) .*; urgency=')

def run(cmd):
	p = subprocess.Popen(cmd,
		stdout=subprocess.PIPE,
		stderr=subprocess.PIPE)
	p.wait()

	if p.returncode != 0:
		raise Exception('`%s` exited with %d' % (' '.join(cmd), p.returncode))

	return p.communicate()[0]

def check_run(*args, **kwargs):
	print('I: running `%s`' % ' '.join(args))

	p = None
	try:
		p = subprocess.Popen(args, **kwargs)
		p.wait()
		if p.returncode != 0:
			raise RunException(p.returncode)
	finally:
		if p:
			p.wait()

def run_sbuild(sb_args, arch, dist, pkg, tmpdir):
	while True:
		try:
			args = []

			if sb_args.sb_user:
				args += ['sudo', '-u', sb_args.sb_user]

			args += [
				'sbuild',
				'--source',
				'--arch', arch,
				'--dist', dist,
				'-j', str(sb_args.sb_jobs),
				'--post-build-commands',
					'{} '.format(os.path.abspath(__file__)) +
					'--sbuild-hook-clean=%%SBUILD_DSC',
				os.path.abspath(pkg.path)]

			check_run(*args, cwd=tmpdir)
			return
		except RunException as e:
			res = raw_input(
				'E: `%s` on %s-%s failed with exit code %d. '
				'Try again? [y/N] '
					% (pkg.name, dist, arch, e.code))
			if res != 'y':
				raise

			pkg.rebuild_tar()

class Package(object):
	def __init__(self, path, name, version, quilted):
		self.path = path
		self.name = name
		self.version = version
		self.quilted = quilted

	def tar_path(self):
		v = self.version.split('-')[0]
		tar =  '%s_%s.orig.tar.xz' % (self.name, v)
		return os.path.normpath('%s/../%s' % (pkg.path, tar))

	def rebuild_tar(self):
		if self.quilted:
			self.quilt_clean()
			check_run('tar', 'cfJ', self.tar_path(), pkg.path)

	def quilt_clean(self):
		if self.quilted:
			# The actual source is sometimes modified by patches. Just remove
			# them to keep things clean.
			try:
				subprocess.Popen(['quilt', 'pop', '-a'],
					cwd=pkg.path).wait()
			except OSError as e:
				raise Exception('`quilt` is not installed')

			shutil.rmtree('%s/.pc/' % pkg.path, ignore_errors=True)

	def realpath(self):
		try:
			return os.readlink(self.path)
		except OSError:
			return None

class RunException(Exception):
	def __init__(self, code):
		self.code = code

	def __str__(self):
		return 'Command exited with status: %d' % self.code

class Dists(object):
	default = '%s-%s' % (CURRENT_STABLE, PYARCH_TO_DEBARCH[platform.machine()])
	dists = set()

	def __init__(self):
		envs = run(['schroot', '-l', '--all'])
		envs = [e.replace('source:', '').replace('-sbuild', '').replace('chroot:', '')
			for e in envs.split('\n')
			if e.endswith('sbuild')]

		for e in envs:
			self.dists.add(e)

		if self.dists and self.default not in self.dists:
			self.default = list(self.dists)[0]

	def dump(self):
		print('Available dists (*default):')
		for d in self.get_all():
			star = '*' if d == self.default else ' '
			print('   %s%s' % (star, d))
		sys.exit(0)

	def get_all(self):
		return self.dists

	def get(self, dists):
		ds = set()

		if not dists:
			if self.dists:
				ds.add(self.default)
		elif 'all' in dists:
			ds = self.get_all()
		else:
			for dist in dists:
				for d in self.dists:
					if d.startswith(dist) or d.endswith(dist):
						ds.add(d)

		return ds

class Remotes(object):
	hosts = []
	default = None

	def __init__(self):
		hosts = run(['dput', '--host-list'])
		for h in hosts.split('\n'):
			if len(h.strip()) == 0 or 'Default Method' in h:
				continue
			hh = h.split('  ')[0].split(' => ')
			if hh[0] == DEFAULT_REMOTE:
				self.default = hh[0]
			self.hosts.append(hh)

		if not self.default:
			raise Exception('Default remote %s not found' % DEFAULT_REMOTE)

	def dump(self):
		print('Available remotes (*default):')
		for h in self.hosts:
			star = '*' if h[0] == self.default else ' '
			print('   %s%s (%s)' % (star, h[0], h[1]))
		sys.exit(0)

	def get(self, rs):
		hosts = []

		if not rs:
			hosts.append(self.default)
		else:
			for h in self.hosts:
				if h[0] in rs:
					hosts.append(h[0])

		return hosts

def sbuild_new(desc, repo):
	parts = desc.split('-')
	if len(parts) != 3:
		print('E: Invalid env spec')
		sys.exit(1)

	dist = parts[0]

	if not repo:
		repo = SBUILD_REPO_URLS.get(dist, None)
		if not repo:
			print('E: Invalid distribution name, can\'t find repo for: %s' % dist)
			sys.exit(1)

	arch = parts[2].lower()
	if arch not in SBUILD_ARCHS:
		print('E: Invalid arch name: %s' % parts[2])
		sys.exit(1)

	name = '%s-%s' % (parts[1], arch)

	check_run('sudo', 'sbuild-createchroot',
		'--include=eatmydata,lintian',
		'--arch=%s' % arch,
		'--components=%s' % SBUILD_COMPONENTS[dist],
		'--make-sbuild-tarball=/var/lib/sbuild/%s.tar' % name,
		parts[1],
		tempfile.mkdtemp(),
		repo)

	check_run('echo "command-prefix=eatmydata" | '
		'sudo tee -a /etc/schroot/chroot.d/%s-sbuild-* > /dev/null' % name,
		shell=True)

def sbuild_del(ds):
	print('Going to delete:')
	for d in ds:
		print('    `%s`' % d)

	print()
	res = raw_input('Confirm? [y/N] ')
	if res.lower() != 'y':
		print('Aborting...')
		sys.exit(1)

	for d in ds:
		check_run('sudo', 'schroot',
			'--end-session', '--all-sessions',
			'chroot:%s-sbuild' % d)
		check_run('sudo', 'schroot',
			'--end-session', '--all-sessions',
			'source:%s-sbuild' % d)
		check_run('sudo rm /etc/schroot/chroot.d/%s-sbuild-*' % d,
			shell=True)
		check_run('sudo', 'rm', '/var/lib/sbuild/%s.tar' % d)

def sbuild_update(dists):
	for d in dists:
		parts = d.split('-')
		check_run('sudo', 'sbuild-update',
			'-udcar',
			'--arch', parts[1], parts[0])
	sys.exit(0)

def sbuild_hook_clean(dsc):
	filename, file_extension = os.path.splitext(dsc)

	def unlink(p):
		try:
			os.unlink(p)
		except:
			pass

	unlink(dsc)
	unlink(filename + '.tar.gz')
	unlink(filename + '.tar.bz')
	unlink(filename + '.tar.xz')

def find_changes_file(outdir, pkg):
	files = glob.glob('%s/%s*.changes' % (outdir, pkg))
	if not files:
		raise Exception('Changes file for %s not found' % pkg)
	return files[0]

def get_changelog_version(pkg_path):
	log = '%s/debian/changelog' % pkg_path
	with open(log) as f:
		m = CHANGELOG_VERSION.match(f.read())

	if not m:
		raise Exception('Could not find pkg version in %s', log)

	return m.group(1)

def skip_key(pkg, dist):
	return '%s[%s]' % (pkg.name, dist)

dists = Dists()
remotes = Remotes()

parser = argparse.ArgumentParser(description='Build a Debian package and dput it')
parser.add_argument(
	'packages', metavar='PACKAGE_PATH',
	type=str, nargs='*',
	help='which package(s) to build')
parser.add_argument(
	'-d', '--dist',
	type=str,
	action='append',
	help='which distro to use (may be given multiple times). '+
		'use "all" to build in all. '+
		'otherwise, does prefix/suffix matching on the given values')
parser.add_argument(
	'--ignore-versions',
	action='store_true',
	help='ignore already-built version information and build everything')
parser.add_argument(
	'--list-dists',
	action='store_true',
	help='list all dists known to sbuild')
parser.add_argument(
	'--list-remotes',
	action='store_true',
	help='list all remotes known to dput')
parser.add_argument(
	'--no-versions',
	action='store_true',
	help='if no versions file should be written')
parser.add_argument(
	'-r', '--remote',
	type=str,
	action='append',
	help='which remote to use (may be given multiple times)')
parser.add_argument(
	'--sbuild-del',
	action='store_true',
	help='delete the sbuild envs associated with the selected dists (-d/--dist)')
parser.add_argument(
	'--sbuild-new',
	metavar='<debian-testing-amd64>',
	help='create a new sbuild env, use the format ubuntu-codename-arch or debian-codename-arch')
parser.add_argument(
	'--sbuild-repo-url',
	metavar=SBUILD_REPO_URLS['debian'],
	help='alternative repo URL to use')
parser.add_argument(
	'--sbuild-update',
	action='store_true',
	help='perform apt-get upgrades in the matched dists')
parser.add_argument(
	'--sbuild-hook-clean',
	metavar='<path/to.dsc>',
	help='post-build hook for sbuild')

sb_parser = parser.add_argument_group('sbuild arguments')
sb_parser.add_argument(
	'--sb-user',
	default=None,
	metavar=getpass.getuser(),
	help='which user to run sbuild as')
sb_parser.add_argument(
	'--sb-jobs',
	type=int, metavar=multiprocessing.cpu_count(),
	default=multiprocessing.cpu_count(),
	help='jobs flag to pass to sbuild')

def main():
	def skip_version(pkg, dist):
		return versions.get(skip_key(pkg, dist), None) == pkg.version

	args = parser.parse_args()

	if args.sbuild_hook_clean:
		sbuild_hook_clean(args.sbuild_hook_clean)
		sys.exit(0)

	if args.sbuild_new:
		sbuild_new(args.sbuild_new, args.sbuild_repo_url)
		sys.exit(0)

	if os.path.exists(CFG_FILE):
		dist = args.dist
		remote = args.remote
		pkgs = args.packages

		with open(CFG_FILE) as f:
			parser.parse_args(f.read().split(), namespace=args)

		# Don't allow default arguments to override those given on command line
		if dist:
			args.dist = dist
		if remote:
			args.remote = remote
		if not pkgs:
			for p in args.packages:
				pkgs += glob.glob(p)

		args.packages = pkgs

	versions = {}
	if not args.ignore_versions and os.path.exists(VERSIONS_FILE):
		with open(VERSIONS_FILE) as f:
			versions = json.load(f)

	if args.list_dists:
		dists.dump()
	if args.list_remotes:
		remotes.dump()

	ds = dists.get(args.dist)
	rs = remotes.get(args.remote)

	if not ds:
		raise Exception('No dists matched')

	if args.sbuild_del:
		sbuild_del(ds)
		sys.exit(0)

	if args.sbuild_update:
		sbuild_update(ds)

	pkgs = []

	if not args.packages:
		args.packages = ['.']

	for pkg in args.packages:
		if not os.path.exists(pkg):
			raise Exception('Package %s not found' % pkg)

		ctrl = '%s/debian/control' % pkg
		if not os.path.isfile(ctrl):
			raise Exception('%s not found' % ctrl)
		with open(ctrl) as f:
			head = f.readline().strip()
		name = head.split(':')[1].strip()

		format = '%s/debian/source/format' % pkg
		with open(format) as f:
			quilted = '(quilt)' in f.read()

		pkgs.append(Package(
			path=pkg,
			name=name,
			version=get_changelog_version(pkg),
			quilted=quilted))

	print('Going to build:')
	for pkg in pkgs:
		print('    `%s` (v%s) for' % (pkg.name, pkg.version))
		for d in ds:
			skip = ''
			if skip_version(pkg, d):
				skip = ' (skip - already built)'
			print('        %s%s' % (d, skip))

	print()
	print('And upload to:')
	if rs:
		for r in rs:
			print('	%s' % r)
	else:
		print('	<no uploads>')

	print()
	res = raw_input('Confirm? [y/N] ')
	if res.lower() != 'y':
		print('Aborting...')
		sys.exit(1)

	for pkg in pkgs:
		for d in ds:
			if skip_version(pkg, d):
				continue

			tmpdir = tempfile.mkdtemp(prefix='debs-')
			try:
				pkg.rebuild_tar()

				sb_args = copy.deepcopy(args)

				cfg = os.path.join(pkg.path, '.debs')
				if os.path.exists(cfg):
					with open(cfg) as f:
						parser.parse_args(
							f.read().split(),
							namespace=sb_args)

				parts = d.split('-')
				run_sbuild(sb_args, parts[1], parts[0], pkg, tmpdir)

				pkg.quilt_clean()

				changes_file = find_changes_file(tmpdir, pkg.name)
				for r in rs:
					check_run('dput', r, changes_file)

				versions[skip_key(pkg, d)] = pkg.version
			finally:
				shutil.rmtree(tmpdir)

	if not args.ignore_versions and not args.no_versions:
		with open(VERSIONS_FILE, 'w') as f:
			json.dump(versions, f)

if __name__ == '__main__':
	main()
