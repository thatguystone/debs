#!/usr/bin/env python

from __future__ import print_function

import argparse
import glob
import json
import multiprocessing
import os.path
import platform
import re
import shutil
import subprocess
import sys
import tempfile

CFG_FILE = '.debs'
VERSIONS_FILE = CFG_FILE + '-versions'

DEFAULT_REMOTE = 'default'
CURRENT_STABLE = 'jessie'
PYARCH_TO_DEBARCH = {
	'i386': 'i386',
	'x86_64': 'amd64'
}

SBUILD_ARCHS = set(PYARCH_TO_DEBARCH.values())
SBUILD_REPO_URLS = {
	'debian': 'http://httpredir.debian.org/debian',
	'ubuntu': 'http://us.archive.ubuntu.com/ubuntu/',
}

GEN_GLOBS = [
	'*_*.*.build',
	'*_*.*.changes',
	'*_*.*.deb',
	'*_*.*.dsc',
	'*_*.*.debian.tar.gz',
	'*_*.*.orig.tar.gz',
	'*_*.*.debian.tar.xz',
	'*_*.*.orig.tar.xz',
	'*_*.*.build',
	'*_*.*.upload',
]

CHANGELOG_VERSION = re.compile(r'.* \((.*)\) .*; urgency=')

def run(cmd):
	p = subprocess.Popen(cmd,
		stdout=subprocess.PIPE,
		stderr=subprocess.PIPE)
	p.wait()

	if p.returncode != 0:
		raise Exception('`%s` exited with %d' % (' '.join(cmd), p.returncode))

	return p.communicate()[0]

def check_run(*args, **kwargs):
	print('I: running `%s`' % ' '.join(args))

	p = None
	try:
		p = subprocess.Popen(args, shell=kwargs.get('shell', False))
		p.wait()
		if p.returncode != 0:
			raise RunException(p.returncode)
	finally:
		if p:
			p.wait()

def run_sbuild(arch, dist, pkg):
	while True:
		try:
			check_run('sbuild', '--source',
				'--arch', arch,
				'--dist', dist,
				'-j', str(multiprocessing.cpu_count()),
				pkg.path)
			return
		except RunException as e:
			res = raw_input(
				'E: `%s` on %s-%s failed with exit code %d. '
				'Try again? [y/N] '
					% (pkg.name, dist, arch, e.code))
			if res != 'y':
				raise

			pkg.rebuild_tar()

class Package(object):
	def __init__(self, path, name, version, quilted):
		self.path = path
		self.name = name
		self.version = version
		self.quilted = quilted

	def tar_path(self):
		v = self.version.split('-')[0]
		tar =  '%s_%s.orig.tar.xz' % (self.name, v)
		return os.path.normpath('%s/../%s' % (pkg.path, tar))

	def rebuild_tar(self):
		if self.quilted:
			self.quilt_clean()
			check_run('tar', 'cfJ', self.tar_path(), pkg.path)

	def quilt_clean(self):
		if self.quilted:
			# The actual source is sometimes modified by patches. Just remove
			# them to keep things clean.
			subprocess.Popen(['quilt', 'pop', '-a'],
				cwd=pkg.path).wait()
			shutil.rmtree('%s/.pc/' % pkg.path, ignore_errors=True)

class RunException(Exception):
	def __init__(self, code):
		self.code = code

	def __str__(self):
		return 'Command exited with status: %d' % self.code

class Dists(object):
	default = '%s-%s' % (CURRENT_STABLE, PYARCH_TO_DEBARCH[platform.machine()])
	dists = set()

	def __init__(self):
		envs = run(['schroot', '-l', '--all'])
		envs = [e.replace('source:', '').replace('-sbuild', '').replace('chroot:', '')
			for e in envs.split('\n')
			if e.endswith('sbuild')]

		for e in envs:
			self.dists.add(e)

		if self.dists and self.default not in self.dists:
			self.default = list(self.dists)[0]

	def dump(self):
		print('Available dists (*default):')
		for d in self.get_all():
			star = '*' if d == self.default else ' '
			print('   %s%s' % (star, d))
		sys.exit(0)

	def get_all(self):
		return self.dists

	def get(self, dists):
		ds = set()

		if not dists:
			if self.dists:
				ds.add(self.default)
		elif 'all' in dists:
			ds = self.get_all()
		else:
			for dist in dists:
				for d in self.dists:
					if d.startswith(dist) or d.endswith(dist):
						ds.add(d)

		return ds

class Remotes(object):
	hosts = []
	default = None

	def __init__(self):
		hosts = run(['dput', '--host-list'])
		for h in hosts.split('\n'):
			if len(h.strip()) == 0 or 'Default Method' in h:
				continue
			hh = h.split('  ')[0].split(' => ')
			if hh[0] == DEFAULT_REMOTE:
				self.default = hh[0]
			self.hosts.append(hh)

		if not self.default:
			raise Exception('Default remote %s not found' % DEFAULT_REMOTE)

	def dump(self):
		print('Available remotes (*default):')
		for h in self.hosts:
			star = '*' if h[0] == self.default else ' '
			print('   %s%s (%s)' % (star, h[0], h[1]))
		sys.exit(0)

	def get(self, rs):
		hosts = []

		if not rs:
			hosts.append(self.default)
		else:
			for h in self.hosts:
				if h[0] in rs:
					hosts.append(h[0])

		return hosts

def sbuild_new(desc):
	parts = desc.split('-')
	if len(parts) != 3:
		print('E: Invalid env spec')
		sys.exit(1)

	repo = SBUILD_REPO_URLS.get(parts[0], None)
	if not repo:
		print('E: Invalid distribution name: %s' % parts[0])
		sys.exit(1)

	arch = parts[2].lower()
	if arch not in SBUILD_ARCHS:
		print('E: Invalid arch name: %s' % parts[2])
		sys.exit(1)

	name = '%s-%s' % (parts[1], arch)

	check_run('sudo', 'sbuild-createchroot',
		'--include=eatmydata,lintian',
		'--arch=%s' % arch,
		'--make-sbuild-tarball=/var/lib/sbuild/%s.tar' % name,
		parts[1],
		tempfile.mkdtemp(),
		repo)

	check_run('echo "command-prefix=eatmydata" | '
		'sudo tee -a /etc/schroot/chroot.d/%s-sbuild-* > /dev/null' % name,
		shell=True)

def sbuild_del(ds):
	print('Going to delete:')
	for d in ds:
		print('    `%s`' % d)

	print()
	res = raw_input('Confirm? [y/N] ')
	if res.lower() != 'y':
		print('Aborting...')
		sys.exit(1)

	for d in ds:
		check_run('sudo', 'schroot',
			'--end-session', '--all-sessions',
			'chroot:%s-sbuild' % d)
		check_run('sudo', 'schroot',
			'--end-session', '--all-sessions',
			'source:%s-sbuild' % d)
		check_run('sudo rm /etc/schroot/chroot.d/%s-sbuild-*' % d,
			shell=True)
		check_run('sudo', 'rm', '/var/lib/sbuild/%s.tar' % d)

def update(dists):
	for d in dists:
		parts = d.split('-')
		check_run('sudo', 'sbuild-update',
			'-udcar',
			'--arch', parts[1], parts[0])
	sys.exit(0)

def find_changes_file(outdir, pkg):
	files = glob.glob('%s/%s*.changes' % (outdir, pkg))
	if not files:
		raise Exception('Changes file for %s not found' % pkg)
	return files[0]

def clean():
	for g in GEN_GLOBS:
		for f in glob.glob(g):
			os.unlink(f)
	sys.exit(0)

def rm_gen_files(outdir, pkg, changes):
	with open(changes) as f:
		ch = f.read()

	fs = list([changes] +
		['%s/%s' % (outdir, f) for f in re.findall(r'\w{32} \d* .* .* (.*)', ch)] +
		glob.glob('%s/%s*.build' % (outdir, pkg)) +
		glob.glob('%s/%s*.upload' % (outdir, pkg)))
	for f in fs:
		os.unlink(f)

def get_changelog_version(pkg):
	log = '%s/debian/changelog' % pkg
	with open(log) as f:
		m = CHANGELOG_VERSION.match(f.read())

	if not m:
		raise Exception('Could not find pkg version in %s', log)

	return m.group(1)

def skip_key(pkg, dist):
	return '%s[%s]' % (pkg.name, dist)

def skip_version(pkg, dist):
	return versions.get(skip_key(pkg, dist), None) == pkg.version

dists = Dists()
remotes = Remotes()

parser = argparse.ArgumentParser(description='Build a Debian package and dput it')
parser.add_argument(
	'packages', metavar='PACKAGE_PATH',
	type=str, nargs='*',
	help='which package(s) to build')
parser.add_argument(
	'-c', '--clean',
	action='store_true',
	help='clean up all debian-generated files in this directory')
parser.add_argument(
	'-d', '--dist',
	type=str,
	action='append',
	help='which distro to use (may be given multiple times). '+
		'use "all" to build in all. '+
		'otherwise, does prefix/suffix matching on the given values')
parser.add_argument(
	'--ignore-versions',
	action='store_true',
	help='ignore already-built version information and build everything')
parser.add_argument(
	'--list-dists',
	action='store_true',
	help='list all dists known to sbuild')
parser.add_argument(
	'--list-remotes',
	action='store_true',
	help='list all remotes known to dput')
parser.add_argument(
	'--no-versions',
	action='store_true',
	help='if no versions file should be written')
parser.add_argument(
	'-r', '--remote',
	type=str,
	action='append',
	help='which remote to use (may be given multiple times)')
parser.add_argument(
	'--sbuild-del',
	action='store_true',
	help='delete the sbuild envs associated with the selected dists (-d/--dist)')
parser.add_argument(
	'--sbuild-new',
	metavar='<debian-testing-amd64>',
	help='create a new sbuild env, use the format ubuntu-codename-arch or debian-codename-arch')
parser.add_argument(
	'--sbuild-update',
	action='store_true',
	help='perform apt-get upgrades in the matched dists')

args = parser.parse_args()

if args.sbuild_new:
	sbuild_new(args.sbuild_new)
	sys.exit(0)

if args.clean:
	clean()

if os.path.exists(CFG_FILE):
	pkgs = args.packages
	with open(CFG_FILE) as f:
		parser.parse_args(f.read().split(), namespace=args)

	for p in args.packages:
		pkgs += glob.glob(p)

	args.packages = pkgs

versions = {}
if not args.ignore_versions and os.path.exists(VERSIONS_FILE):
	with open(VERSIONS_FILE) as f:
		versions = json.load(f)

if args.list_dists:
	dists.dump()
if args.list_remotes:
	remotes.dump()

ds = dists.get(args.dist)
rs = remotes.get(args.remote)

if not ds:
	raise Exception('No dists matched')
if not rs:
	raise Exception('No remotes matched')

try:
	p = subprocess.Popen(['quilt', '--version'], stdout=subprocess.PIPE)
	p.communicate()
except OSError as e:
	raise Exception('`quilt` is not installed')

if args.sbuild_del:
	sbuild_del(ds)
	sys.exit(0)

if args.sbuild_update:
	update(ds)

pkgs = []

if not args.packages:
	args.packages = ['.']

for pkg in args.packages:
	if not os.path.exists(pkg):
		raise Exception('Package %s not found' % pkg)

	ctrl = '%s/debian/control' % pkg
	if not os.path.isfile(ctrl):
		raise Exception('%s not found' % ctrl)
	with open(ctrl) as f:
		head = f.readline().strip()
	name = head.split(':')[1].strip()

	format = '%s/debian/source/format' % pkg
	with open(format) as f:
		quilted = '(quilt)' in f.read()

	pkgs.append(Package(
		path=pkg,
		name=name,
		version=get_changelog_version(pkg),
		quilted=quilted))

print('Going to build:')
for pkg in pkgs:
	print('    `%s` (v%s) for' % (pkg.name, pkg.version))
	for d in ds:
		skip = ''
		if skip_version(pkg, d):
			skip = ' (skip - already built)'
		print('        %s%s' % (d, skip))

print()
res = raw_input('Confirm? [y/N] ')
if res.lower() != 'y':
	print('Aborting...')
	sys.exit(1)

orig_tars = set()
for pkg in pkgs:
	outdir = os.path.abspath('%s/..' % pkg.path)
	for d in ds:
		if skip_version(pkg, d):
			continue

		pkg.rebuild_tar()

		parts = d.split('-')
		run_sbuild(parts[1], parts[0], pkg)

		pkg.quilt_clean()

		changes = find_changes_file(outdir, pkg.name)
		for r in rs:
			check_run('dput', r, changes)

		rm_gen_files(outdir, pkg.name, changes)

		versions[skip_key(pkg, d)] = pkg.version

if not args.ignore_versions and not args.no_versions:
	with open(VERSIONS_FILE, 'w') as f:
		json.dump(versions, f)
